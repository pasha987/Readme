Slip 15
Q1-
#include <stdio.h>
#include <stdlib.h>
#include <dirent.h>
#include <sys/stat.h>

int main() {
    DIR *dp;
    struct dirent *entry;
    struct stat filestat;
    long n;

    printf("Enter size in bytes: ");
    scanf("%ld", &n);

    dp = opendir(".");
    if (dp == NULL) {
        printf("Cannot open current directory.\n");
        exit(1);
    }

    printf("\nFiles greater than %ld bytes:\n", n);

    while ((entry = readdir(dp)) != NULL) {
        if (stat(entry->d_name, &filestat) == 0) {
            if (S_ISREG(filestat.st_mode)) {   // Only regular files
                if (filestat.st_size > n) {
                    printf("%s (size: %ld bytes)\n", entry->d_name, filestat.st_size);
                }
            }
        }
    }

    closedir(dp);
    return 0;
}
Q2-
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <sys/wait.h>

pid_t child_pid;

void child_death_handler(int sig) {
    printf("\nChild process finished.\n");
}

void alarm_handler(int sig) {
    printf("\nChild timed out! Killing child process...\n");
    kill(child_pid, SIGKILL);
}

int main() {
    char command[50];

    printf("Enter a Linux command to run: ");
    scanf("%s", command);

    signal(SIGCHLD, child_death_handler);
    signal(SIGALRM, alarm_handler);

    child_pid = fork();

    if (child_pid < 0) {
        printf("Fork failed!\n");
        exit(1);
    }

    if (child_pid == 0) {
        // Child: execute the command
        execlp(command, command, NULL);
        printf("Command execution failed!\n");
        exit(1);
    } 
    else {
        // Parent: wait up to 5 seconds
        alarm(5);

        wait(NULL);   // Wait until child exits or is killed
        alarm(0);     // Cancel pending alarm if child finishes early
    }

    return 0;
}
